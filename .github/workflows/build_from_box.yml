name: Build Vagrant Boxes (from other boxes)

env:
  PACKER_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}

on:
  # Allows this workflow to be run manually from the "Actions" tab
  workflow_dispatch:
    inputs:
      # A dropdown menu to select the box directory
      distro:
        description: 'Which box to build?'
        required: true
        type: choice
        options:
          - ubuntu-24.04
      
      architecture:
        description: 'Which architecture?'
        required: true
        type: choice
        options:
          - amd64
          - arm64

      # A menu to select the provider. These names MUST match
      # the start of the 'name' of your 'source' blocks in Packer.
      provider:
        description: 'Which provider?'
        required: true
        type: choice
        options:
          - virtualbox
          - vmware
          - libvirt

jobs:
  build:
    name: Build (${{ inputs.provider }} on ${{ inputs.distro }} [${{ inputs.architecture }}])
    environment: vmware
    # GitHub runner
    runs-on: "${{ inputs.architecture == 'arm64' && 'macos-15' || 'ubuntu-24.04' }}"

    strategy:
      # Don't cancel other builds if one fails (e.g., if VBox fails, let QEMU continue)
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Get info
        run: |
          if [ "$RUNNER_OS" == "macOS" ]; then
            uname -a
            echo "=== CPU ==="
            echo " Cores: $(sysctl -n hw.ncpu)"
            echo " Type:  $(sysctl -n machdep.cpu.brand_string)"
            echo "=== MEMORY ==="
            total_mem_bytes=$(sysctl -n hw.memsize)
            echo " RAM:   $((total_mem_bytes / 1024 / 1024)) MB"
            echo "=== DISK ==="
            diskutil list
            df -h

            virt_support=0
            virt_type="None"
            if sysctl -n kern.hv_support &>/dev/null && [ "$(sysctl -n kern.hv_support)" -eq 1 ]; then
              virt_support=1
              virt_type="Hypervisor.framework"
            elif sysctl -n machdep.cpu.features &>/dev/null && sysctl -n machdep.cpu.features | grep -qw VMX; then
              virt_support=1
              virt_type="VMX"
            elif [ -d /System/Library/Frameworks/Hypervisor.framework ]; then
              virt_support=1
              virt_type="Hypervisor.framework"
            fi
            echo "=== Virtualzation ==="
            echo "Hardware support: $virt_support"
            echo "Virtualization type: $virt_type"
          elif [ "$RUNNER_OS" == "Linux" ]; then
            uname -a
            echo "=== CPU ==="
            echo " Cores: $(lscpu | grep '^CPU(s):' | awk '{print $2}')"
            echo " Type:  $(lscpu | grep 'Model name:' | sed 's/Model name:[ \t]*//')"
            echo "=== MEMORY ==="
            total_mem=$(free -m | awk '/^Mem:/ {print $2}')
            echo " RAM:   ${total_mem} MB"
            echo "=== DISK ==="
            lsblk
            df -h

            if grep -E -q 'vmx' /proc/cpuinfo; then
              virt_hw="VMX (Intel VT-x)"
            elif grep -E -q 'svm' /proc/cpuinfo; then
              virt_hw="SVM (AMD-V)"
            else
              virt_hw="No hardware virtualization support"
            fi

            VCORES=$(egrep -c '(vmx|svm)' /proc/cpuinfo)
            hypervisor=$(lscpu | awk -F: '/Hypervisor vendor/ {gsub(/^[ \t]+/, "", $2); print $2}')
            if [[ -z "$hypervisor" ]]; then
              hypervisor="Not running inside VM"
            fi

            virt_flag=$(lscpu | awk -F: '/Virtualization type/ {gsub(/^[ \t]+/, "", $2); print $2}')
            if [[ -z "$virt_flag" ]]; then
              virt_flag="Unknown"
            fi
            
            echo "=== Virtualzation ==="
            echo "Hardware support:  $virt_hw"
            echo "Virtualization type: $virt_flag"
            echo "Cores with VT-x/AMD-V: $VCORES"
            echo "Hypervisor detected: $hypervisor"

            if [ "$VCORES" -gt 0 ]; then
              echo "Virtualization available: YES"
            else
              echo "Virtualization available: NO"
            fi
          else
            echo "Error: unexpected RUNNER_OS: $RUNNER_OS"
            exit 1
          fi

      - name: Install Vagrant
        run: |
          if [ "$RUNNER_OS" == "macOS" ]; then
            echo "Installing Vagrant on macOS (arm64)..."
            brew install --cask vagrant
          elif [ "$RUNNER_OS" == "Linux" ]; then
            echo "Installing Vagrant on Linux (amd64)..."
            # Añadimos el repositorio de HashiCorp para la última versión
            curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
            echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
            sudo apt-get update
            sudo apt-get install -y vagrant
          fi
          echo "Vagrant installed."
          vagrant --version

      - name: Install Dependencies (QEMU / Libvirt)
        if: inputs.provider == 'libvirt'
        run: |
          # Linux (amd64) requires hypervisor packages
          # macOS (arm64) use preinstalled QEMU 
          if [ "$RUNNER_OS" == "macOS" ]; then
            echo "Installing QEMU/Libvirt packages on macOS..."
            brew install qemu
            brew install libvirt
            brew services stop libvirt
            echo 'unix_sock_ro_perms = "0777"' > /opt/homebrew/etc/libvirt/libvirtd-modified.conf
            echo 'unix_sock_rw_perms = "0770"' >> /opt/homebrew/etc/libvirt/libvirtd-modified.conf
            echo 'unix_sock_admin_perms = "0700"' >> /opt/homebrew/etc/libvirt/libvirtd-modified.conf
            echo 'unix_sock_dir = "/opt/homebrew/var/run/libvirt"' >> /opt/homebrew/etc/libvirt/libvirtd-modified.conf
            echo "Starting libvirt..."
            sudo /opt/homebrew/opt/libvirt/sbin/libvirtd -f /opt/homebrew/etc/libvirt/libvirtd-modified.conf -d
            echo "List libvirt directories"
            ls -l /opt/homebrew/var/run/libvirt/
            ls -l /opt/homebrew/var/run
          elif [ "$RUNNER_OS" == "Linux" ]; then
            echo "Installing QEMU/Libvirt packages on Linux..."
            sudo apt-get update
            sudo apt-get install -y qemu-kvm libvirt-daemon-system libvirt-clients virtinst bridge-utils qemu-utils libvirt-dev libguestfs-tools
            echo "Enabling KVM..."
            echo 'KERNEL=="kvm", GROUP="kvm", MODE="0666", OPTIONS+="static_node=kvm"' | sudo tee /etc/udev/rules.d/99-kvm4all.rules
            sudo udevadm control --reload-rules
            sudo udevadm trigger --name-match=kvm
            sudo usermod -aG kvm $USER
            sudo usermod -aG libvirt $USER
            sudo chmod o+rw /var/run/libvirt/libvirt-sock
            sudo systemctl restart libvirtd
          else
            echo "Error: unexpected RUNNER_OS: $RUNNER_OS"
            exit 1
          fi
          echo "QEMU / Libvirt dependencies installed."
          echo "Installing vagrant-libvirt and vagrant-qemu plugins..."
          vagrant plugin install vagrant-libvirt vagrant-qemu

      - name: Install Dependencies (VirtualBox)
        if: inputs.provider == 'virtualbox'
        run: |
          if [ "$RUNNER_OS" == "macOS" ]; then
            echo "Downloading VirtualBox on macOS (arm64)..."
            curl -L -o virtualbox.dmg "https://download.virtualbox.org/virtualbox/7.2.4/VirtualBox-7.2.4-170995-macOSArm64.dmg"
            hdiutil attach virtualbox.dmg -nobrowse -quiet
            echo "Installing VirtualBox..."
            sudo installer -pkg /Volumes/VirtualBox/VirtualBox.pkg -target /
            hdiutil detach /Volumes/VirtualBox -quiet
          elif [ "$RUNNER_OS" == "Linux" ]; then
            echo "Installing VirtualBox on Linux (amd64)..."
            curl -fsSL https://www.virtualbox.org/download/oracle_vbox_2016.asc | sudo gpg --dearmor -o /usr/share/keyrings/oracle-virtualbox-2016.gpg
            echo "deb [arch=amd64 signed-by=/usr/share/keyrings/oracle-virtualbox-2016.gpg] https://download.virtualbox.org/virtualbox/debian $(lsb_release -cs) contrib" | sudo tee /etc/apt/sources.list.d/virtualbox.list
            sudo apt-get update
            sudo apt-get install -y virtualbox-7.2 linux-headers-"$(uname -r)"
            sudo /sbin/vboxconfig
          else
            echo "Error: unexpected RUNNER_OS: $RUNNER_OS"
            exit 1
          fi
          echo "VirtualBox installed."
          vboxmanage --version
  
      - name: Install Dependencies (VMware)
        if: inputs.provider == 'vmware'
        env:
          VMWARE_URL_ARM64: ${{ secrets.VMWARE_FUSION_URL }}
          VMWARE_URL_AMD64: ${{ secrets.VMWARE_WORKSTATION_URL }}
        run: |
          if [ "$RUNNER_OS" == "macOS" ]; then
            if [ -z "$VMWARE_URL_ARM64" ]; then echo "Error: VMWARE_FUSION_URL secret is not set."; exit 1; fi
            echo "Downloading VMware Fusion (arm64)..."
            DMG_FILE="VMware-Fusion.dmg"
            curl --silent --show-error -L -o $DMG_FILE "$VMWARE_URL_ARM64"
            
            echo "Installing VMware..."
            MOUNT_POINT="/Volumes/VMwareFusion_$$"
            if ! hdiutil attach "$DMG_FILE" -nobrowse -mountpoint "$MOUNT_POINT"; then
              echo "Error: $DMG_FILE cannot be mounted"
              exit 1
            fi

            if [ ! -d "$MOUNT_POINT" ]; then
              echo "MOUNT_POINT=$MOUNT_POINT does not exist after attach"
              exit 1
            fi

            echo "Mounted at: $MOUNT_POINT"
            ls -la "$MOUNT_POINT"
            
            APP_PATH=$(find "$MOUNT_POINT" -maxdepth 1 -type d -name "*.app" | head -n 1 || true)
            if [ -z "$APP_PATH" ]; then
              echo "No app found at $MOUNT_POINT"
              hdiutil detach "$MOUNT_POINT" -quiet || true
              exit 1
            fi
            
            echo "Copying $(basename "$APP_PATH") to /Applications..."
            TARGET="/Applications/"
            echo "Copying $APP_PATH -> $TARGET..."
            sudo cp -R "$APP_PATH" "$TARGET"
            echo "Copy done."

            if [ -x "/Applications/VMware Fusion.app/Contents/Library/Initialize VMware Fusion.tool" ]; then
              echo "Initializing VMware Fusion..."
              sudo "/Applications/VMware Fusion.app/Contents/Library/Initialize VMware Fusion.tool" || true
            fi
            if [ -x "/Applications/VMware Fusion.app/Contents/Library/services/startup.sh" ]; then
              echo "Running startup script VMware Fusion..."
              sudo "/Applications/VMware Fusion.app/Contents/Library/services/startup.sh" || true
            fi
            
            hdiutil detach "$MOUNT_POINT" -quiet
          elif [ "$RUNNER_OS" == "Linux" ]; then
            if [ -z "$VMWARE_URL_AMD64" ]; then echo "Error: VMWARE_WORKSTATION_URL secret is not set."; exit 1; fi
            echo "Downloading VMware Workstation (amd64)..."
            curl --silent --show-error -L -o vmware.bundle "$VMWARE_URL_AMD64"
            chmod +x vmware.bundle
            echo "Installing VMware..."
            sudo ./vmware.bundle --console --required --eulas-agreed
          else
            echo "Error: unexpected RUNNER_OS: $RUNNER_OS"
            exit 1
          fi
          echo "VMware installed."
          vmware --version
          echo "Compiling VMware modules..."
          sudo vmware-modconfig --console --install-all

          echo "Installing Vagrant VMware Utility"
          if [ "$RUNNER_OS" == "macOS" ]; then
            curl -L -o vmware-utility.dmg https://releases.hashicorp.com/vagrant-vmware-utility/1.0.24/vagrant-vmware-utility_1.0.24_darwin_arm64.dmg
            sudo launchctl load -w /Library/LaunchDaemons/com.vagrant.vagrant-vmware-utility.plist
          else
            curl -L -o vmware-utility.deb https://releases.hashicorp.com/vagrant-vmware-utility/1.0.24/vagrant-vmware-utility_1.0.24-1_amd64.deb
            sudo apt-get install -y ./vmware-utility.deb
            sudo systemctl restart vagrant-vmware-utility
          fi

          echo "Installing vagrant-vmware-desktop plugin..."
          vagrant plugin install vagrant-vmware-desktop

      - name: Free disk space
        uses: jlumbroso/free-disk-space@main
        if: inputs.architecture == 'amd64'
        with:
          tool-cache: false
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: false

      # --- BUILD STEP ---
      - name: Validate and Build with Packer
        id: build
        run: |
          REPO_HOME="${{ github.workspace }}"
          PACKER_TEMPLATE=$REPO_HOME/template.pkr.hcl
          cd $REPO_HOME
          
          # parse distro -> os & ver (e.g., ubuntu-24.04 => ubuntu and 24.04)
          DISTRO="${{ inputs.distro }}"
          OS_NAME="$(echo "$DISTRO" | cut -d- -f1)"
          VERSION="$(echo "$DISTRO" | cut -d- -f2)"
          BOX_DIR=$REPO_HOME/os_configs/${OS_NAME}/${VERSION}/box
          
          echo "Using BOX_DIR=${BOX_DIR}"
          if [ ! -d "$BOX_DIR" ]; then
            echo "Error: expected box directory not found: $BOX_DIR"
            ls -la "$(dirname "$BOX_DIR")" || true
            exit 1
          fi

          cd "${BOX_DIR}"
          echo "output_dir=${BOX_DIR}" >> "$GITHUB_OUTPUT"
          echo "Written output_dir: ${GITHUB_OUTPUT}"
          
          echo "Initializing Packer template..."
          packer init $PACKER_TEMPLATE

          echo "Validating Packer template..."
          # use the box-specific pkrvars
          if [ ! -f "box.pkrvars.hcl" ]; then
            echo "Error: box.pkrvars.hcl not found in $BOX_DIR"
            exit 1
          fi
          packer validate -var="build_arch=${{ inputs.architecture }}" -var-file="box.pkrvars.hcl" $PACKER_TEMPLATE

          echo "Building box for: ${{ inputs.provider }} on ${{ inputs.architecture }}"
          PACKER_LOG=1 packer build -var="build_arch=${{ inputs.architecture }}" -var-file="box.pkrvars.hcl" -only="vagrant.${{ inputs.provider }}" $PACKER_TEMPLATE

      # --- ARTIFACT UPLOAD STEP ---
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.distro }}-${{ inputs.architecture }}-${{ inputs.provider }}.box
          path: ${{ steps.build.outputs.output_dir }}/output-*/package.box
          if-no-files-found: error
          retention-days: 14 # Keep artifact for 14 days (default is 90)

      - name: Check disk space
        if: always()
        run: |
          df -h
